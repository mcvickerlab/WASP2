/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    nf-outrider Nextflow config file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    WASP2 + OUTRIDER Pipeline for Aberrant Expression Detection
----------------------------------------------------------------------------------------
*/

// Pipeline metadata
manifest {
    name            = 'wasp2/nf-outrider'
    author          = 'WASP2 Team'
    description     = 'WASP2 + OUTRIDER for aberrant expression and mono-allelic expression detection'
    mainScript      = 'main.nf'
    nextflowVersion = '!>=23.04.0'
    version         = '1.0.0'
}

// Default parameters
params {
    // Input/Output
    input                   = null    // Samplesheet CSV (required)
    outdir                  = './results'
    publish_dir_mode        = 'copy'

    // Reference genome
    gtf                     = null    // Gene annotation GTF (required)
    fasta                   = null    // Reference FASTA (optional, for validation)

    // Variant data (required for WASP2)
    vcf                     = null    // VCF/BCF/PGEN variant file
    vcf_tbi                 = null    // VCF tabix index

    // WASP2 options
    skip_wasp_filter        = false   // Skip WASP mapping bias filter (use original BAMs)
    wasp_threads            = 4       // WASP2 internal threads
    wasp_use_rust           = true    // Use Rust acceleration (61x faster)

    // Allele counting options
    min_reads               = 10      // Min total reads for a variant
    min_allele_count        = 3       // Min count for minor allele

    // Gene aggregation options
    aggregation_method      = 'sum'   // How to aggregate variant counts to genes: 'sum', 'mean', 'max'
    feature_type            = 'gene'  // GTF feature type for aggregation

    // OUTRIDER options
    outrider_padj           = 0.05    // Adjusted p-value cutoff for outliers
    outrider_zScore         = 2       // Z-score cutoff for outlier calling
    outrider_min_samples    = 10      // Minimum samples for OUTRIDER fitting
    outrider_q              = null    // Encoding dimension (auto-estimated if null)
    outrider_iterations     = 15      // Max OUTRIDER iterations
    outrider_convergence    = 1e-5    // Convergence threshold
    outrider_min_count      = 10      // Min count per gene for expression filter

    // MAE (Mono-allelic Expression) options
    skip_mae                = false   // Skip MAE analysis
    mae_min_count           = 10      // Min allele count for MAE test
    mae_padj                = 0.05    // MAE p-value cutoff
    mae_alt_ratio           = 0.8     // Alt allele ratio threshold for MAE

    // ML Output options
    output_format           = null    // ML output formats: zarr,parquet,anndata (comma-separated)

    // Processing options
    skip_multiqc            = false

    // Resource limits
    max_cpus                = 16
    max_memory              = '128.GB'
    max_time                = '240.h'

    // Generic options
    help                    = false
    version                 = false
    tracedir                = "${params.outdir}/pipeline_info"
}

// Load configuration files
includeConfig 'conf/base.config'
includeConfig 'conf/modules.config'

// Execution profiles
profiles {
    debug {
        dumpHashes              = true
        process.beforeScript    = 'echo $HOSTNAME'
        cleanup                 = false
    }
    conda {
        conda.enabled           = true
        docker.enabled          = false
        singularity.enabled     = false
        process.conda           = "${projectDir}/../../environment.yml"
    }
    docker {
        docker.enabled          = true
        conda.enabled           = false
        singularity.enabled     = false
        docker.runOptions       = '-u $(id -u):$(id -g)'
    }
    singularity {
        singularity.enabled     = true
        singularity.autoMounts  = true
        conda.enabled           = false
        docker.enabled          = false
    }
    test {
        includeConfig 'conf/test.config'
    }
    test_stub {
        includeConfig 'conf/test_stub.config'
    }
    test_full {
        includeConfig 'conf/test_full.config'
    }
    test_local {
        includeConfig 'conf/test_local.config'
    }
}

// Execution reports
def trace_timestamp = new java.util.Date().format('yyyy-MM-dd_HH-mm-ss')
timeline {
    enabled = true
    file    = "${params.tracedir}/execution_timeline_${trace_timestamp}.html"
}
report {
    enabled = true
    file    = "${params.tracedir}/execution_report_${trace_timestamp}.html"
}
trace {
    enabled = true
    file    = "${params.tracedir}/execution_trace_${trace_timestamp}.txt"
}
dag {
    enabled = true
    file    = "${params.tracedir}/pipeline_dag_${trace_timestamp}.html"
}

// Export these variables to prevent local Python/Perl libs from conflicting
env {
    PYTHONNOUSERSITE = 1
    R_PROFILE_USER   = "/.Rprofile"
    R_ENVIRON_USER   = "/.Renviron"
}

// Container overrides
def wasp2_container = 'ghcr.io/mcvickerlab/wasp2:1.4.0'
def outrider_container = 'quay.io/biocontainers/bioconductor-outrider:1.26.3--r44he5774e6_0'
process {
    withName: 'WASP2_COUNT|WASP2_ML_OUTPUT|AGGREGATE_COUNTS|MERGE_COUNTS|MAE_DETECT' {
        container = wasp2_container
    }
    withName: 'OUTRIDER_FIT' {
        container = outrider_container
    }
}

// Capture exit codes from upstream processes when piping
process.shell = ['/bin/bash', '-euo', 'pipefail']

// Function to ensure resources don't exceed limits
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "WARNING: Invalid max_memory '${params.max_memory}', using default"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "WARNING: Invalid max_time '${params.max_time}', using default"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min(obj, params.max_cpus as int)
        } catch (all) {
            println "WARNING: Invalid max_cpus '${params.max_cpus}', using default"
            return obj
        }
    }
}
